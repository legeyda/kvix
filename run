#!/usr/bin/env sh
set -eu

# env: PYTHON?
# env: USE_VENV?
main() {
	: "${PYTHON:=python3}"
	#: "${KVIX_PYENV_PYTHON_VERSION:=miniconda3-3.11-25.1.1-2}"

	target="${TARGET:-./target}"

	_main__subcommand="$1"
	shift
	"run_$_main__subcommand" "$@"
	unset _main__subcommand
}

run_vscode() {
	echo 'configuring vscode...'
	mkdir -p .vscode/venv
	"$PYTHON" -m venv .vscode/venv
	.vscode/venv/bin/python -m pip install . tox \
			types-pkg-resources \
			types-pynput \
			types-PyYAML \
			funcy-stubs \
			types-Jinja2
	code .
	# todo PS1="(kvix/.vscode/venv) ${PS1:-}"
	echo 'done configuring vscode'
}


run_clean() {
	echo 'cleaning project directory...'
	rm -vrf ./build ./dist *.egg-info src/*.egg-info .tox
	find . -name '*.pyc' -exec echo rm '{}' ';'
	find . -type d -empty -print0 | xargs -0 -n1 echo rmdir
	echo 'done cleaning'
}

run_check() {
	echo running all tox environment...
	maybe_create_venv
	"$PYTHON" -m pip install tox
	"$PYTHON" -m tox -v
	echo done runing tox
}

# env: target
#      USE_VENV?
#      PYTHON? 
maybe_create_venv() {
	if [ "true" = "${USE_VENV:-true}" ]; then
		local path="build/run/venv/${1:-$target}"
		#local path=$(mktemp -d -t "kvix-run-$target.$(date +%Y-%m-%d_%H-%M-%S).XXXX")
		mkdir -p "$path"
		echo "creating python virtual environment in '$path'"
		"$PYTHON" -m venv "$path"
		PYTHON="$path/bin/python3"
		echo "now using '$PYTHON' as python executable"
	fi
}

# env: PYTHON
# env: USE_VENV
run_pyproject() {
	echo building pyproject...
	maybe_create_venv
	"$PYTHON" -m pip install install 'build==1.0.3'
	"$PYTHON" -m build
	echo done building pyproject
}

run_flatpak() {
	# requires requirements-parser build

	# build kvix wheel
	run_flatpak_target="$target"/flatpak
	rm -rf "$run_flatpak_target"/wheel
	mkdir -p "$run_flatpak_target"/wheel
	python -m build --wheel --outdir="$run_flatpak_target"/wheel
	kvix_wheel_file=$(ls "$run_flatpak_target"/wheel)

	# apply manifest template
	sed -e "s|{{ *kvix_wheel_file *}}|$kvix_wheel_file|g" flatpak/kvix.template \
			> "$run_flatpak_target"/manifest.yaml

	# generate dependency module
	run_flatpak_pip_generator \
			--runtime='org.freedesktop.Sdk//25.08' \
 			--pyproject-file=pyproject.toml \
			--output="$run_flatpak_target/deps.json"

	# copy flatpak files
	for x in tkinter ; do #appindicator
		cp flatpak/flatpak-$x.json "$target/flatpak"
	done

	# build flatpak

	flatpak run org.flatpak.Builder --force-clean --user --install-deps-from=flathub --repo=repo "$run_flatpak_target"/builddir "$run_flatpak_target"/manifest.yaml
	#flatpak run io.github.legeyda.Kvix
	flatpak build-bundle repo "$run_flatpak_target"/kvix.flatpak io.github.legeyda.Kvix --runtime-repo=https://flathub.org/repo/flathub.flatpakrepo
}

run_flatpak_pip_generator() {
	run_flatpak_pip_generator_script="$target"/flatpak-pip-generator.py
	if [ ! -e "$run_flatpak_pip_generator_script" ]; then
		mkdir -p "$target"
		curl --fail --silent --show-error --location --output "$run_flatpak_pip_generator_script" \
				'https://raw.githubusercontent.com/flatpak/flatpak-builder-tools/refs/heads/master/pip/flatpak-pip-generator.py'
	fi
	python3 "$run_flatpak_pip_generator_script" "$@"
	unset run_flatpak_pip_generator_script
}


run_build() {
	sub=$(echo "$1" | tr - _)
	shift
	run_build_"$sub" "$@"
}


download_file() {
	if [ -f ./build/download/"$2" ]; then
		return
	fi
	mkdir -p ./build/download
	curl --fail --silent --show-error --location --output ./build/download/"$2" "$1"
}

run_build_python() {
	# build portable python distribution with dependencies

	if [ -f ./build/python/python.tar.gz ]; then
		return
	fi
	
	# download portable dist
	download_file https://github.com/astral-sh/python-build-standalone/releases/download/20250918/cpython-3.13.7+20250918-x86_64-unknown-linux-gnu-install_only_stripped.tar.gz python.tar.gz
	mkdir -p ./build/python	
	(cd ./build/python && rm -rf python && tar xzvf ../download/python.tar.gz)

	# patch libtcl and libtk
	download_file https://archive.ubuntu.com/ubuntu/pool/main/t/tcl8.6/libtcl8.6_8.6.14+dfsg-1build1_amd64.deb libtcl.deb
	download_file https://archive.ubuntu.com/ubuntu/pool/main/t/tk8.6/libtk8.6_8.6.14-1build1_amd64.deb libtk.deb
	for x in libtcl libtk; do
		mkdir -p ./build/python/"$x"
		(cd ./build/python/"$x" && ar x ../../download/$x.deb && tar --zstd -xvf data.tar.zst)
		rm -f ./build/python/python/lib/${x}8.6.so
		(cd ./build/python && cp ./$x/usr/lib/x86_64-linux-gnu/${x}8.6.so ./python/lib )
	done

	./build/python/python/bin/python -m pip install 'setuptools<81'
	util_base_image
	docker run --interactive --rm --name=kvix-dev \
			"--user=$(id -u):$(id -g)" \
			--volume="$(pwd):/workdir" \
			--workdir=/workdir \
			kvix-dev ./build/python/python/bin/python -m pip install .
	./build/python/python/bin/python -m pip uninstall --yes kvix

	# bundle python dist
	(cd ./build/python && tar czf ./python.tar.gz python)

}

run_build_portable() {
	run_build_python
	rm -rf ./build/portable
	mkdir -p ./build/portable
	cp -r ./build/python/python ./build/portable
	./build/portable/python/bin/python -m pip install .
	version=$(./build/portable/python/bin/python -c 'from importlib.metadata import version; print(version("kvix"))')

	mkdir -p ./build/portable/kvix-"$version"-portable
	mv ./build/portable/python ./build/portable/kvix-"$version"-portable
	cat > ./build/portable/kvix-"$version"-portable/run <<'EOF'
#!/bin/sh
script_dir=$(dirname "$0")
script_dir=$(CDPATH= cd -- "$script_dir" && pwd -P)
exec "$script_dir"/python/bin/python -m kvix.app "$@"
EOF
	chmod +x ./build/portable/kvix-"$version"-portable/run

	mkdir -p ./dist
	(cd ./build/portable && tar czf ../../dist/kvix-"$version"-portable.tar.gz kvix-"$version"-portable)
}

run_build_debug() {
	rm -rf  "$target"/debug/python "$target"/debug/python-full-3.13.7-linux-x86_64
	unzip ./build/download/python-full-3.13.7-linux-x86_64.zip -d "$target"/debug
	mv "$target"/debug/python-full-3.13.7-linux-x86_64 "$target"/debug/python

	util_base_image
	docker run --interactive --rm --name=kvix-dev \
			"--user=$(id -u):$(id -g)" \
			--volume="$(pwd):/workdir" \
			--workdir=/workdir \
			kvix-dev "$target"/debug/python/bin/python -m pip install .
	#
	"$target"/debug/python/bin/python -m pip install conda-pack
	"$target"/debug/python/bin/conda-pack -p "$target"/debug/python -o "$target"/debug/dist.tar.gz
	
}


# env: USE_VENV
# env: python
run_pyinstaller() {
	echo 'building pyinstaller...'
	maybe_create_venv
	"$PYTHON" -m pip install 'pyinstaller==6.1.0' 'setuptools-git-versioning==1.13.5' .
	"$PYTHON" -m PyInstaller pyinstaller.spec
	echo 'done building pyinstaller'
}

run_msys2pyinstaller() {
	echo 'building msys2 pyinstaller...'
	maybe_create_venv
	# these are normal project dependencies
	"$PYTHON" -m pip install \
			"funcy==1.17" \
			"pynput==1.7.6"	\
			"pystray==0.19.4" \
			"pkgconfig==1.5.5" \
			"PyYAML==6.0.1"	\
			"Jinja2==3.1.2"	\
			"tk==0.1.0"
	# this has dependency issue, install with no-deps
	"$PYTHON" -m pip install --no-deps "pyclip==0.7.0"
	# build tools
	"$PYTHON" -m pip install 'pyinstaller==6.1.0' 'setuptools-git-versioning==1.13.5'
	"$PYTHON" -m PyInstaller pyinstaller.spec
	echo 'done building msys2 pyinstaller'
}

run_publish() {
	echo 'uploading artifacts to pypi...'
	maybe_create_venv
	"$PYTHON" -m pip install twine
	"$PYTHON" -m twine upload --repository pypi dist/*
	echo 'done uploading artifacts to pypi'
}






run_py() {
	docker rm --force kvix-dev 2>/dev/null || true

	util_base_image
	run_install_pyenv

	# python version
	_run_py__current_version="${KVIX_PYENV_PYTHON_VERSION:-miniconda3-3.11-25.1.1-2}"
	if [ "$_run_py__current_version" != "${_run_py__cached_version:-}" ]; then
		_run_py__cached_version="$_run_py__current_version"		
		docker run --interactive --rm --name=kvix-dev --env=HOME --env=PYENV_HOME --env=_run_py__cached_version="$_run_py__cached_version" \
			--volume="$HOME:$HOME" \
			"--user=$(id -u):$(id -g)" \
			kvix-dev bash -euc '"$PYENV_HOME"/bin/pyenv install --skip-existing "$_run_py__cached_version"'
		_run_py__prefix=$("$PYENV_HOME"/bin/pyenv prefix "$_run_py__cached_version")
	fi

	# python venv
	_run_py__current_venv="$HOME/.cache/kvix-dev/venv/$_run_py__current_version"
	if [ "$_run_py__current_venv" != "${_run_py__cached_venv:-}" ]; then
		_run_py__cached_venv="$_run_py__current_venv"
		"$_run_py__prefix/bin/python" -m venv "$_run_py__cached_venv"
		docker run --interactive --rm --name=kvix-dev --env=_run_py__cached_venv="$_run_py__cached_venv" --env=HOME \
				"--user=$(id -u):$(id -g)" \
				--volume="$HOME:$HOME" \
				--workdir="$(pwd)" \
				kvix-dev sh -euc '"$_run_py__cached_venv"/bin/pip install .[dev]'
	fi


	# run
	"$_run_py__cached_venv"/bin/python "$@"
}

run_install_pyenv() {
	: "${PYENV_HOME:=$HOME/.pyenv}"
	export PYENV_HOME
	if [ ! -x "$PYENV_HOME/bin/pyenv" ]; then
		mkdir -p "$PYENV_HOME"
		if command -v git 2>/dev/null; then
			git clone https://github.com/pyenv/pyenv.git "$PYENV_HOME"
		else
			docker run --interactive --rm --name=kvix-dev --env=HOME --env=PYENV_HOME \
				--volume="$PYENV_HOME:$PYENV_HOME" --workdir="$PYENV_HOME" \
				"--user=$(id -u):$(id -g)" \
				alpine/git:v2.49.1 clone https://github.com/pyenv/pyenv.git .
		fi
	fi
}

util_docker_available() {
	if [ -z "${_util_docker_available:-}" ]; then
		if docker run hello-world > /dev/null 2>&1; then
			_util_docker_available=true
		else
			_util_docker_available=false
		fi
	fi
	if [ true != "$_util_docker_available" ]; then
		return 1
	fi
}






util_base_image() {
	if [ true = "${_util_base_image__flag:-false}" ]; then
		return
	fi

	if util_docker_available; then
		docker build --file=- --tag=kvix-dev --progress=plain . <<EOF
FROM ubuntu
RUN apt-get --yes update && apt-get --yes install pkg-config libcairo2-dev build-essential
RUN apt-get --yes install libgirepository1.0-dev
RUN apt-get --yes install curl git
RUN apt-get --yes install libncurses-dev libreadline-dev libssl-dev
RUN apt-get --yes install libc6-dev
RUN apt-get --yes install cmake
RUN apt-get --yes install libgirepository-2.0-dev
RUN apt-get --yes update && apt-get --yes install --no-install-recommends clang
EOF
	fi
	_util_base_image__flag=true
}









util_profile() {
	set +eu
	. "$HOME/.profile"
	set -eu
}

util_git() {
	if command -v git > /dev/null; then
		git "$@"
	elif command -v docker > /dev/null; then
		docker pull alpine/git > /dev/null
		docker run --interactive --tty --rm --user=$(id -u):$(id -g) --env=HOME="$HOME" \
				--volume=/etc/passwd:/etc/passwd:ro --volume=/etc/group:/etc/group:ro \
				--volume=/:/host-root-fs \
				--workdir=/host-root-fs"$(pwd)" \
				alpine/git "$@"
	else
		echo 'util_git: neither git nor docker avilable' >&2
	fi
}

util_git_clone() {
	util_git clone "$@"
}

# fun: util_lineinfile LINE FILE
util_lineinfile() {
	if [ -s "$2" ]; then
		if grep -F -q "$1" "$2"; then
			return
		fi
		printf '\n%s' "$1" >> "$2"
	elif [ -f "$2" ]; then
		printf '%s' "$1" > "$2"
	fi
}


main "$@" # entry point
